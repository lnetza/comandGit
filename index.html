<html>
    <head>
        <title>Home</title>

        <img src="header.png">

    </head>
    <body>
        <div>
            <h3>Comandos de git</h3>
            
            <p><strong> touch</strong> // crea un archivo</p>

            <p><strong> rm</strong> //borra un archivo</p>

            <p><strong> rm -rf </strong>//borra la carpeta</p>

            <p><strong> vim</strong> file.txt //crea un archivo nuevo</p>

            <p><strong> :wq</strong> // cierra un archivo</p>


            <p><strong> git init</strong> // nos crea un repositorio de manera local y lo hará en la carpeta donde estamos posicionados o 
            se le puede pasar [nombre_de_la_carpeta] y creará la carpeta con ese nombre.</p>

            <p><strong> ls -a</strong> nos muestra los archivos o carpetas ocultas en la terminal</p>

            <p><strong> git status</strong> // vemos los archivos Untracked files que aun no se agregan del Working Directory al Stagin</p>
            
            <p>
            Untracked files: Son archivos que están en nuestro Working Directory, lo que aparezca en rojo es lo que se ha modificado y hay que pasarlo al Staging.</p>

            <p><strong> git add [archivo] </strong>: Nos agrega al archivo al staging area(el limbo) ** -A** nos agrega todos los archivos
                
                //Una vez agregado el archivo al stagin, si se personalizo git se debe ver el cambio en color verde
                //Si se quiere regresar el archivo del Stagin y regresarlo nuevamente a WorDirectory ya sea por algun error o por que nos equivocamos etc
                // se puede usar el siguiente comando: git rm --cached "file"
            </p>
            <p><strong> git rm --cached </strong>: Nos devolvemos un paso</p>
            <p><strong> git rm -f [file] </strong>: Elimina el archivo por completo BORRADO FORSOZO</p>
            <p><strong> git add -n [file] </strong>: Que no haga nada</p>
            <p><strong> Git commit -m [“mensaje”]</strong>Es bueno ser descriptivos con el mensaje para saber lo que se hizo en ese commit y para informar al resto de personas.</p>
            <p><strong> –amend</strong> :concatena nuevos cambios con cambios previos es decir haciendo una análogia si envie un e-mail pero se me olvido adjuntar 
                                        el archivo con -amend adjunto ese archivo y se envia en un solo email o commit es decir concatena nuevos cambios al último commit</p>
            <p><strong>git log</strong>: nos muestra la historia de todos los commits que hemos realizados. </p>
            <p><strong>git tag</strong>: nos permite agregar etiquetas a nuestros cambios.</p>
            <p><strong>-a </strong>para la anotación</p>
            <p><strong>-m </strong>para el mensaje</p>
            <p><strong>-l </strong>nos muestra la lista de etiquetas</p>
            <p><strong>-f</strong>para renombrar</p>
            <p><strong>-d</strong>para borrar</p>
            <p><strong>En resumen los tipos de tag</strong></p>
            <div>
            <p>
                <h4>–tag ligera</h4>
                git tag 1.0 + "SHA" 
                git tag 1.0 02512454212dfd2s...
            </p>
            <p>
                <h4>**tag anotada</h4>
                
                git tag -a 1.0 -m 'version estable' 0251245421...
                git tag -a "version" -m "mensaje" "sha"
            </p> 
            <p>  
                <h4>*Opciones
                **Borrar tags</h4>
                
                git tag -d 1.0
                git tag -d "versíon"
            </p> 
            <p>   
                <h4>**Renombrar tags</h4>
                
                git tag -f -a  0.1 'iniciando el proyecto' + sha
            </p> 
            <p>  
                <h4>**Listar tags</h4>
                
                git tag -l
            </p> 
            <p>   
                *Nota
                Si no se coloca el sha al final del mensaje, el tag se colocorá al ultimo commit
            </p>   
            </div>
        </div>
        <p><strong>git log --oneline</strong>: te pone el log de commits de manera resumida</p>
        <p><strong>git log --oneline --graph</strong>: grafico de como va avanzando la historia del proyecto</p>
        <p><strong>git log --oneline -3</strong>: ver solo 3 commits</p>
        <p><strong>git log --oneline -1</strong>: ver último commit</p>
        <h4>Revisando cambios de versiones</h4>
        <p><strong>git diff</strong>: para comparar los cambios de la version actual vs un commit anterior ejemplo: git diff + elshadeuncommit</p>
        <p><strong>git diff</strong>: git diff 0.5 0.3 comparar tags</p>
        <p><strong>git diff</strong>: git diff [version 1] [version 2] ejemplo: git diff 8c340c5 43da8a9 para comparar 2 SHA o commits</p>
        <p><strong>git reset --soft</strong> git reset --soft masElSHA</p>
        <p><strong>git reset</strong> Hay que tener en cuenta que si usas git reset --soft los archivos bajan o se quedan en el stagin listos para hacer commit nuevamente
            Tienes 10 commits y borras el numero 7, los commits 8, 9 y 10 también se borran, y tendras un nuevo commit que tomara el numero 8 y el 9 y 10 se fusionan con el 8.
        </p>
        <p><strong>git reset --mixed</strong> git reset --mixed masElSha con esto los commits en ves de bajar al stagin se bajan a WorkDirectory</p>
        <p><strong>git reset --hard</strong> git reset --hard [SHA]: regresa hasta el commit del [SHA] que se le especifique, --hard modifica a nivel de disco es decir te borra los archivos u te sobrescirbe unarchivo, pero tambien
            se puede volver a restaurar siempre y cuando tengamos la lista de SHAs o el último SHA commiteado pero poder regresar a él, especificando git reset --hard [últimoSHA o al SHAdeseado]
        </p>
        <h4>Ramas</h4>
        
        <p>Las ramas ayudan a gestionar el flujo de trabajo en un equipo de desarrollo.
            git branch nombrerama : comando para crear la rama</p>
        <p>Las ramas son muy importantes si quieres trabajar con un equipo y no quieres tocar la rama master para no crear conflictos</p>
        <p><strong>git branch [nombre] </strong> se crea una nueva rama</p>
        <p><strong>git branch -l namebranch </strong>: listar ramas</p>
        <p><strong>git branch -d namebranch </strong>: eliminar una rama</p>
        <p><strong>git branch -D namebranch </strong>: eliminar branch’s que tiene commits</p>
        <p><strong>git branch -m namebranchedit newnamebranch</strong> : renombrar o editar nombre de la rama incluso se puede editar la rama master</p>

        <h4>git checkout (Moviéndonos entre ramas y versiones)</h4>
        <p><strong>git checkout nombredelarama</strong>: nos movemos a la rama</p>
        <p><strong>git checkout [sha]</strong>: Nos permite mover entre ramas y entre commits, no vamos a borrar nada simplemente vamos a ver como
        era o como se veia la web o el proyecto en ese preciso commit con ese preciso SHA especificado. 
        Acá es donde podemos movernos en el tiempo.
        </p>
        <p><strong>git checkout -b [nombrerama o SHA]</strong>: Nos permite crear una nueva rama e inmediatamente movernos a la rama o SHA especificado
        por lo tanto ya no estaremos en master si no en la rama creada</p>
    
        <p>con git checkout nombreRama Nos movemos a la rama especificada y hacemos cambios en nuestro proyecto en esa rama especifica, por lo cual solo va a afectar
            a la rama en la que estamos y no a las demas ramas ni tampoco a la rama principal o master; si se agregan archivos y estos estan en untrackfiles estos seguiran
            ahí inlcuso si no cambiamos de rama, desaparecen si y solo sí hacemos un git add "file" y su commit respectivo entonces el commit es tomado por la rama en la
            que nos encontremos; una vez hecho esto, dichos archivos ya no van aparecer en stagin cada que nos cambiemos de ramas
        </p>
        <blockquote>Es como si te “siguieran” a todas partes hasta que los agregues a una rama especifica, y entonces dejan de “seguirte”</blockquote>

        <h4>git merge (Mezclando ramas y resolviendo conflictos)</h4>
        <p><strong>git merge [rama]</strong> : Nos permite mezclar los cambios realizados en dicha rama con la rama en la que estamos.</p>
        <p><strong>fast-forward</strong> :los mezcla automáticamente</p>
        <p><strong>recursive/auto-merging</strong>: ambas ramas salieron al mismo tiempo y hay algo nuevo en la rama que la otra no recuerda, por eso hace la mezcla recursiva.
            manual merge: nos va a tocar decirle a git específicamente los cambios que queremos mezclar
        </p>
        <p><strong>CONFLICT: </strong>cuando al hacer el git merge, ambas ramas no pueden mezclarse porque las dos modifican una misma parte del código.
             Por lo tanto, toca manualmente resolver el conflicto y decidir con cual o qué nos quedamos. Se debe hacer un commit una vez resuelto.
        </p>
        <p><strong>git rebase</strong> : hace prácticamente lo mismo que merge, cambiamos la historia de nuestro proyecto sin crear bifurcaciones del proyecto. 
            Es mejor usar merge Usar solo git rebase de manera local.
        </p>
        <p><strong>git rebase -i</strong> : de manera interactiva, nos abrira el editor que tengamos definido en la configuración de git para poder especificar el commit.
        </p>
        <p><p>Referencia 1</p><strong>git stash</strong>: esto nos va permitir guardar los cambios hechos del staging area de la rama en la que nos encontremos, es decir si aun no queremos hacer el commit de estos
        cambios a la rama podemos usar stash para guardar momentaneamente esos cambios de esta manera si nos movemos a otra rama esos cambios que aun no estan confirmados como commit y 
        se encuentran aun el stagin area no apareceran a la rama a la que nos movimos</p>
        <P><strong>git stash list</strong>: nos muestra la lista de stash que tengamos.</P>
        <p><strong>git stash drop stash@{numero}</strong>: nos permite borrar un stash</p>
        <p><stron>git stash apply</stron>: aplicamos el último cambio es decir (ver referencia 1) traemos de vuelta el stash que quedo almacenado al stagin para hacerle add . y commit</p>
        <p><stron>git stash apply stash@{numeroStash}</stron>: especificamos que stash queremos restablecer para poder reflejarlo en stagin y poder hacer git add. y commit</p>
        <h4>Cherry pick eligiendo commits selectivamente</h4>
        <p>Si estás trabajando en una rama, pero de repente notas que hiciste un cambio en la rama que no debías, para esto podemos usar cherry pick. Este comando nos puede salvar la vida, ya que nos permite sacar cambios específicos de una rama y mezclarlos en otra.
        </p>
        <p><strong>Generar llave SSH comando:</strong> ssh-keygen -t rsa -b 4096 -C "tuemail.com"</p>
        <p>Se abre github y se pega en settings</p>
        <p><strong>git remote (Añadiendo un repositorio remoto o en la nube a uno local)</strong>
        Tenemos que crear una conexión entre tu repositorio local y tu repositorio remoto para que puedas compartirlo con la comunidad.
        Para esto vamos a usar un nuevo comando que en este caso es git remote. Por convención lo nombramos “origin”. Para borrarlo podemos 
        usar git remote remove y el nombre del repositorio.
        </p>
        <p>
        <strong>Añadiendo repositorio remoto</strong>
        Para lograrlo debemos copiar el link que nos arroja la opción “clonar o descargar” de la página de nuestro repositorio en github y 
        utilizar el comando: git remote add origin [linkDelRepositorio] Si no mostro ningún mensaje de error, quiere decir que podemos trabajar 
        remotamente desde el repositorio.
        </p>
        <p>Para verificar que tengamos nuestro repositorio correctamente enlazado usamos:git remote -v
        Para remover nuestro repositorio remoto usamos:
        <strong>git remote remove origin</strong> origin: Nombre del repositorio remoto como referencia al local le ponemos, por convención le ponemos origin.
        </p>
        <p><strong> pull/fetch (Trayendo cambios desde el repositorio remoto)</strong>
        Vamos a compartir nuestro código con el repositorio remoto. Antes de poder enviar cambios tengo que tener los mismos cambios en el repositorio remoto que en el repositorio local.
        Para traer los cambios del repositorios remoto vamos a usar el comando git fetch. Este comando recibe dos parámetros 1. desde donde y hacia donde van.
        Luego de traer los cambios, debemos mezclarlos con la rama que estamos usando en local. Para esto usamos git merge.
        </p>

        <p><strong>git pull/fetch (Trayendo cambios desde el repositorio remoto)</strong>
        Vamos a compartir nuestro código con el repositorio remoto. Antes de poder enviar cambios tengo que tener los mismos cambios en el repositorio remoto que en el repositorio local.
        Para traer los cambios del repositorios remoto vamos a usar el comando git fetch. Este comando recibe dos parámetros 1. desde donde y hacia donde van.
        Luego de traer los cambios, debemos mezclarlos con la rama que estamos usando en local. Para esto usamos git merge.
        </p>
        <p>2 formas de traer tus cambios de github a tu repo local:</p>

        <p> <strong>git fetch</strong> : descarga los cambios a una rama generalmente llamada origin/master, seguido de esto tienes que fuisonar esa rama</p>
        <p>
        <ul>
        <li>git fetch origin master </li>
        <li>origin= remoto | master= rama del remoto</li>
        <li>ahora tienes una rama llamada origin/master</li>
        <li>que pueedes ver con 'git branch -a'</li>
        <li>git merge origin/master</li>
        <li>si obtienes un error usar la siguiente linea</li>
        <li>git merge origin/master --allow-unrelated-histories</li>
        </ul>
        <blockquote>--allow-unrelated-histories se agregó porque el repositorio local invie tiene un histórico de commits diferente que el repositorio
        remoto que Leonidas creó en Github. De esta manera le dices a tu repositorio local que deseas mezclar los commits de tu repositorio remoto
        con tu repositorio local aunque estos no estén relacionados hasta el momento. Luego de esa mezcla ya no necesitarás más la bandera, porque 
        ahora ambos repositorios si poseen una relación
        </blockquote>
        <p><strong>git pull origin master</strong> : es como ejecutar los 2 pasos anteriores(fetch y merge) en uno solo</p>
        </p>

        <blockquote><strong>Para evitar lo anterior, es mejor crear el repositorio en github y hacer lo siguiente:</strong></blockquote>
        
        
        <ul>
        <li>git init [nombre-proyecto-github]</li>
        <li>cd [nombre-proyecto-github]</li>
        <li>git remote add origin [SSH/HTTPS]</li>
        <li>git pull origin master

        </ul>
        <p>
        <strong>git push (Enviando cambios al repositorio remoto)</strong>

        <p>Para enviar nuestro código al repositorio remoto vamos a usar el comando git push. Así logramos que otras personas tengan acceso a nuestro proyecto.
        Cuando esto termine tendremos acceso a nuestro trabajo desde la plataforma de GitHub.
        Lo primero que debemos hacer es enviar nuestros tags en el proyecto.
        también recordemos que podemos eviar ramas, lo que también posdemos hacer a través del uso del comando git push [nombre de la rama].
        </p>
        Comando para subir cambios a github:
        <ul>
            <li>git push origin master</li>

        Tambien podemos enviar los tags:
            <li>git push origin master --tags</li>
        

        Podemos enviar otras ramas:
            <li>git push origin [otra_rama]</li>
        
        </ul>
        </p>
        <p><strong>GitHub projects, el SCRUM de GitHub</strong></p>
        
        <p>
        GitHub tiene unas herramientas increíbles para nuestros proyectos. Una de estas herramientas es el projects de GitHub, la cual nos da la posibilidad de tener un mayor control del desarrollo de nuestro proyecto.
        Aquí como en la metodología de SCRUM tenemos la posibilidad de saber qué tenemos pendiente por hacer, cuáles son las features que se encuentran en desarrollo, identificar los bugs que emergen de nuestro proyecto, y los features que debemos revisar.
        </p>
        <P>Columnas Basicas en tu proyecto:
        <ul>
            <li>TODO: Son las cosas por hacer.</li>
            <li>WIP: Work in Progress. En que estamos trabajando.</li>
            <li> Bugs: Cosas que hay que arreglar de manera prioritaria.</li>
            <li>Waiting for review: nos sirve para cuando trabajamos con los pulls requests, ya que se espera que alguien revise nustro codigo.</li>
            <li>Done: Cuando la tarea ha finalizado.</li>
        
        </ul>    
        </P>
        <footer>
            <p><center>-Comandos básicos de git-</center></p>
            <img src="footer-img.png">
        </footer>
    
    </body>
</html>