<html>
    <head>
        <title>Home</title>

        <img src="header.png">

        <style>
            body {
                margin: 10 5 5 5;
                border: 3px dashed black;
                border-bottom: 0;
            }
        </style>
    </head>
    <body>
        <div>
            <h3>Comandos de git</h3>
            
            <p><strong> touch</strong> // crea un archivo</p>

            <p><strong> rm</strong> //borra un archivo</p>

            <p><strong> rm -rf </strong>//borra la carpeta</p>

            <p><strong> vim</strong> file.txt //crea un archivo nuevo</p>

            <p><strong> :wq</strong> // cierra un archivo</p>


            <p><strong> git init</strong> // nos crea un repositorio de manera local y lo hará en la carpeta donde estamos posicionados o 
            se le puede pasar [nombre_de_la_carpeta] y creará la carpeta con ese nombre.</p>

            <p><strong> ls -a</strong> nos muestra los archivos o carpetas ocultas en la terminal</p>

            <p><strong> git status</strong> // vemos los archivos Untracked files que aun no se agregan del Working Directory al Stagin</p>
            
            <p>
            Untracked files: Son archivos que están en nuestro Working Directory, lo que aparezca en rojo es lo que se ha modificado y hay que pasarlo al Staging.</p>

            <p><strong> git add [archivo] </strong>: Nos agrega al archivo al staging area(el limbo) ** -A** nos agrega todos los archivos
                
                //Una vez agregado el archivo al stagin, si se personalizo git se debe ver el cambio en color verde
                //Si se quiere regresar el archivo del Stagin y regresarlo nuevamente a WorDirectory ya sea por algun error o por que nos equivocamos etc
                // se puede usar el siguiente comando: git rm --cached "file"
            </p>
            <p><strong> git rm --cached </strong>: Nos devolvemos un paso</p>
            <p><strong> git rm -f [file] </strong>: Elimina el archivo por completo BORRADO FORSOZO</p>
            <p><strong> git add -n [file] </strong>: Que no haga nada</p>
            <p><strong> Git commit -m [“mensaje”]</strong>Es bueno ser descriptivos con el mensaje para saber lo que se hizo en ese commit y para informar al resto de personas.</p>
            <p><strong> –amend</strong> :concatena nuevos cambios con cambios previos es decir haciendo una análogia si envie un e-mail pero se me olvido adjuntar 
                                        el archivo con -amend adjunto ese archivo y se envia en un solo email o commit es decir concatena nuevos cambios al último commit</p>
            <p><strong>git log</strong>: nos muestra la historia de todos los commits que hemos realizados. </p>
            <p><strong>git tag</strong>: nos permite agregar etiquetas a nuestros cambios.</p>
            <p><strong>-a </strong>para la anotación</p>
            <p><strong>-m </strong>para el mensaje</p>
            <p><strong>-l </strong>nos muestra la lista de etiquetas</p>
            <p><strong>-f</strong>para renombrar</p>
            <p><strong>-d</strong>para borrar</p>
            <p><strong>En resumen los tipos de tag</strong></p>
            <div>
            <p>
                <h4>–tag ligera</h4>
                git tag 1.0 + "SHA" 
                git tag 1.0 02512454212dfd2s...
            </p>
            <p>
                <h4>**tag anotada</h4>
                
                git tag -a 1.0 -m 'version estable' 0251245421...
                git tag -a "version" -m "mensaje" "sha"
            </p> 
            <p>  
                <h4>*Opciones
                **Borrar tags</h4>
                
                git tag -d 1.0
                git tag -d "versíon"
            </p> 
            <p>   
                <h4>**Renombrar tags</h4>
                
                git tag -f -a  0.1 'iniciando el proyecto' + sha
            </p> 
            <p>  
                <h4>**Listar tags</h4>
                
                git tag -l
            </p> 
            <p>   
                *Nota
                Si no se coloca el sha al final del mensaje, el tag se colocorá al ultimo commit
            </p>   
            </div>
        </div>
        <p><strong>git log --oneline</strong>: te pone el log de commits de manera resumida</p>
        <p><strong>git log --oneline --graph</strong>: grafico de como va avanzando la historia del proyecto</p>
        <p><strong>git log --oneline -3</strong>: ver solo 3 commits</p>
        <p><strong>git log --oneline -1</strong>: ver último commit</p>
        <h4>Revisando cambios de versiones</h4>
        <p><strong>git diff</strong>: para comparar los cambios de la version actual vs un commit anterior ejemplo: git diff + elshadeuncommit</p>
        <p><strong>git diff</strong>: git diff 0.5 0.3 comparar tags</p>
        <p><strong>git diff</strong>: git diff [version 1] [version 2] ejemplo: git diff 8c340c5 43da8a9 para comparar 2 SHA o commits</p>
        <p><strong>git reset --soft</strong> git reset --soft masElSHA</p>
        <p><strong>git reset</strong> Hay que tener en cuenta que si usas git reset --soft los archivos bajan o se quedan en el stagin listos para hacer commit nuevamente
            Tienes 10 commits y borras el numero 7, los commits 8, 9 y 10 también se borran, y tendras un nuevo commit que tomara el numero 8 y el 9 y 10 se fusionan con el 8.
        </p>
        <p><strong>git reset --mixed</strong> git reset --mixed masElSha con esto los commits en ves de bajar al stagin se bajan a WorkDirectory</p>
        <p><strong>git reset --hard</strong> git reset --hard [SHA]: regresa hasta el commit del [SHA] que se le especifique, --hard modifica a nivel de disco es decir te borra los archivos u te sobrescirbe unarchivo, pero tambien
            se puede volver a restaurar siempre y cuando tengamos la lista de SHAs o el último SHA commiteado pero poder regresar a él, especificando git reset --hard [últimoSHA o al SHAdeseado]
        </p>
        <h4>Ramas</h4>
        
        <p>Las ramas ayudan a gestionar el flujo de trabajo en un equipo de desarrollo.
            git branch nombrerama : comando para crear la rama</p>
        <p>Las ramas son muy importantes si quieres trabajar con un equipo y no quieres tocar la rama master para no crear conflictos</p>
        <p><strong>git branch [nombre] </strong> se crea una nueva rama</p>
        <p><strong>git branch -l namebranch </strong>: listar ramas</p>
        <p><strong>git branch -d namebranch </strong>: eliminar una rama</p>
        <p><strong>git branch -D namebranch </strong>: eliminar branch’s que tiene commits</p>
        <p><strong>git branch -m namebranchedit newnamebranch</strong> : renombrar o editar nombre de la rama incluso se puede editar la rama master</p>

        <h4>git checkout (Moviéndonos entre ramas y versiones)</h4>
        <p><strong>git checkout nombredelarama</strong>: nos movemos a la rama</p>
        <p><strong>git checkout [sha]</strong>: Nos permite mover entre ramas y entre commits, no vamos a borrar nada simplemente vamos a ver como
        era o como se veia la web o el proyecto en ese preciso commit con ese preciso SHA especificado. 
        Acá es donde podemos movernos en el tiempo.
        </p>
        <p><strong>git checkout -b [nombrerama o SHA]</strong>: Nos permite crear una nueva rama e inmediatamente movernos a la rama o SHA especificado
        por lo tanto ya no estaremos en master si no en la rama creada</p>
    
        <p>con git checkout nombreRama Nos movemos a la rama especificada y hacemos cambios en nuestro proyecto en esa rama especifica, por lo cual solo va a afectar
            a la rama en la que estamos y no a las demas ramas ni tampoco a la rama principal o master; si se agregan archivos y estos estan en untrackfiles estos seguiran
            ahí inlcuso si no cambiamos de rama, desaparecen si y solo sí hacemos un git add "file" y su commit respectivo entonces el commit es tomado por la rama en la
            que nos encontremos; una vez hecho esto, dichos archivos ya no van aparecer en stagin cada que nos cambiemos de ramas
        </p>
        <blockquote>Es como si te “siguieran” a todas partes hasta que los agregues a una rama especifica, y entonces dejan de “seguirte”</blockquote>

        <h4>git merge (Mezclando ramas y resolviendo conflictos)</h4>
        <p><strong>git merge [rama]</strong> : Nos permite mezclar los cambios realizados en dicha rama con la rama en la que estamos.</p>
        <p><strong>fast-forward</strong> :los mezcla automáticamente</p>
        <p><strong>recursive/auto-merging</strong>: ambas ramas salieron al mismo tiempo y hay algo nuevo en la rama que la otra no recuerda, por eso hace la mezcla recursiva.
            manual merge: nos va a tocar decirle a git específicamente los cambios que queremos mezclar
        </p>
        <p><strong>CONFLICT: </strong>cuando al hacer el git merge, ambas ramas no pueden mezclarse porque las dos modifican una misma parte del código.
             Por lo tanto, toca manualmente resolver el conflicto y decidir con cual o qué nos quedamos. Se debe hacer un commit una vez resuelto.
        </p>
        <p><strong>git rebase</strong> : hace prácticamente lo mismo que merge, cambiamos la historia de nuestro proyecto sin crear bifurcaciones del proyecto. 
            Es mejor usar merge Usar solo git rebase de manera local.
        </p>
        <p><strong>git rebase -i</strong> : de manera interactiva, nos abrira el editor que tengamos definido en la configuración de git para poder especificar el commit.
        </p>
        <p><p>Referencia 1</p><strong>git stash</strong>: esto nos va permitir guardar los cambios hechos del staging area de la rama en la que nos encontremos, es decir si aun no queremos hacer el commit de estos
        cambios a la rama podemos usar stash para guardar momentaneamente esos cambios de esta manera si nos movemos a otra rama esos cambios que aun no estan confirmados como commit y 
        se encuentran aun el stagin area no apareceran a la rama a la que nos movimos</p>
        <P><strong>git stash list</strong>: nos muestra la lista de stash que tengamos.</P>
        <p><strong>git stash drop stash@{numero}</strong>: nos permite borrar un stash</p>
        <p><stron>git stash apply</stron>: aplicamos el último cambio es decir (ver referencia 1) traemos de vuelta el stash que quedo almacenado al stagin para hacerle add . y commit</p>
        <p><stron>git stash apply stash@{numeroStash}</stron>: especificamos que stash queremos restablecer para poder reflejarlo en stagin y poder hacer git add. y commit</p>
        <h4>Cherry pick eligiendo commits selectivamente</h4>
        <p>Si estás trabajando en una rama, pero de repente notas que hiciste un cambio en la rama que no debías, para esto podemos usar cherry pick. Este comando nos puede salvar la vida, ya que nos permite sacar cambios específicos de una rama y mezclarlos en otra.
        </p>
        
        
        <footer>
            <p><center>-Comandos básicos de git-</center></p>>
            <img src="footer-img.png">
        </footer>
    </body>
</html>